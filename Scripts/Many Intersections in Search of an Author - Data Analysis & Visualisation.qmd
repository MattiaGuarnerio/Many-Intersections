---
title: "Many Intersections in Search of an Author"
subtitle: "Data Analysis & Visualisation"
title-block-banner: "#A31621"
author:
  - Mattia Guarnerio (UvA, 14350920)
format: html
toc: true
toc-location: body
fig-cap-location: top
number_sections: true
embed_resources: true
pdf: default
docx: default
bibliography: manyintersections.bib
csl: apa.csl
editor: visual
date: now
eval: true
echo: false
warning: false
---

## 1. Abstract

While *human capital theory* provides key insights into *school-to-work transitions*, it attributes little conceptual relevance to interdependencies between multiply marginalised social identities. This study calls upon intersectional social reproduction feminism to assess intersectional inequalities in material outcomes of school-to-work transitions in Germany.

Leveraging data from Wave 9 of the *Children of Immigrants Longitudinal Survey in Four European Countries* (CILS4EU-DE), I evaluate the joint impact of *parental social class*, *gender*, *migration background*, and *educational track* on *job security* and *early career returns*. The intersectional *Multilevel Analysis of Individual Heterogeneity and Discriminatory Accuracy (MAIHDA)* framework is introduced to systematically distinguish between multiplicative and additive inequalities.

Empirical findings show substantial inequalities in job security and early career returns among German youth, aligning with human capital theory for job security while supporting social reproduction feminism for early career returns. However, the observed effects are primarily *additive* rather than *multiplicative*. This suggests that although lived experiences of multiply marginalised social groups in school-to-work transitions are unique, their material impact on job security and early career returns is uniform across intersectional social positions in parental social class, gender, migration background, and educational track.

Future sociological research may exploit large-scale population register datasets in developing longitudinal and causal extensions for intersectional MAIHDA.

## 2. Research Questions

**Research Question 1 (RQ1):** To what extent does belonging to social categories of parental social class, gender, ethnic background, and educational track predict German young adults’ material outcomes in job security and early career earnings in their school-to-work transitions?

**Research Question 2 (RQ2):** To what extent do intersections, or multiplicative interactions, of social categories of parental social class, gender, ethnic background, and educational track contribute incrementally to explaining German young adults’ material outcomes in job security and early career earnings in their school-to-work transitions?

**Research Question 3 (RQ3):** In the context of school-to-work transitions in Germany, to what extent do multiply marginalized intersectional social positions in parental social class, gender, ethnic background, and educational track experience disadvantages in job security and early career earnings that exceed the additive effects of each social category?

## 3. Preliminary steps

### 3.1 ✧ Installing packages and loading the necessary libraries

To get started, the necessary R [@r_core_team_r_2021] `version 4.3.2` packages must be loaded from the library into the environment. Notable required extensions for analysing and visualising data from CILS4EU-DE [@kalter_children_2024] are:

1.  `tidyverse` [@wickham_welcome_2019] version 3.16.0, for data tidying, wrangling, and visualisation, including `ggplot2` [@wickham_ggplot2_2016] version 3.5.1.

2.  `tictoc` [@sergei_izrailev_tictoc_2024] version 1.2.1, for monitoring the timing of the estimation and loading of Bayesian Monte Carlo Markov chain (MCMC) models.

3.  `rstan` [@guo_rstan_2024] version 2.26.24, and `brms` [@burkner_brms_2017; @burkner_advanced_2018; @burkner_bayesian_2021] version 2.21.0, interfaces to fit Bayesian generalized (non)linear multivariate multilevel models in Stan [@stan_development_team_stan_2024], version 2.3.5.

4.  `tidybayes` [@kay_tidybayes_2023] version 3.0.5, for computing predicted average strata-specific outcomes and strata-level residuals for both the probability of being employed under a permanent contract and net monthly income.

5.  `ggh4x` [@van_den_brand_ggh4x_2024] version 0.2.5, for easily plotting findings across multiple intersectional strata.

Furthermore, `rstan`, `knitr`, and multi-core processing options are set for optimal MCMC estimation and Quarto document compilation. The `knitr` option `include = FALSE` is set whenever the output of a chunk should not be included in the compiled Quarto document.

```{r setup, include = FALSE}
library(tidyverse)
library(tictoc)
library(rstan)
library(brms)
library(tidybayes)
library(ggh4x)

# Multi-core processing for MCMC
options(mc.cores = parallel::detectCores()) 

# Setting to make all code chunks appear in the Quarto document 
knitr::opts_chunk$set(echo = TRUE)

# Setting the working directory for the Quarto project.
knitr::opts_knit$set(root.dir = "C:/Users/Mattia aka Mario/Desktop/UvA/Second Year/Thesis (S. Steinmetz)")

# Compiled Stan models are written to the hard disk in the same directory as the .stan program
rstan_options(auto_write = TRUE)
```

### 3.2 ✧ Importing the data

The analytic sample (N = 2395), sourced from Wave 9 (2022) of CILS4EU-DE and imputed with *Multivariate Imputation by Chained Equations* (MICE), creating 50 complete datasets saved in a `mids` object, can be imported with the `readRDS` function.

All post-imputation and post-strata building analytic samples, `brmsfit` models, tables, and figures sourced and generated from Wave 9 (2022) of CILS4EU-DE for reproducing MCMC estimations and this Quarto project are freely available [here](https://github.com/MattiaGuarnerio/Many-Intersections/).

This R project is distinct from the one for *Data Tidying & Imputation* because CILS4EU-DE data is not open source. Tidying and imputation are thus limited in their reproducibility, while data saved in `imp_main` allow for full, open-access reproducibility of *Data Analysis & Visualisation*. Separating workflows facilitates managing this constraint.

```{r, include = FALSE}
# Importing the mids object containing the 50 multiply imputed analytic samples.

imp_main <- readRDS("Data/Many Intersections in Search of an Author/imp_main")

```

## 4. Modelling the data with intersectional Multilevel Analysis of Individual Heterogeneity and Discriminatory Accuracy (MAIHDA)

In line with the workflow designed by Keller and colleagues [-@keller_educational_2023], two different linear multilevel models are estimated for each outcome of interest, that is, either *job security*, measured by the *probability of being employed under a permanent contract*, and *early career returns*, measured by *net monthly income in euros* (€).

First, a *null* or *simple* intersectional specification is estimated. It is an unadjusted, random intercept model, where the total variance in the outcome variable is disentangled into between-strata and inter-individual differences. The main goal of this specification is to calculate the *Variance Partition Coefficient* (VPC), that is, the proportion of total variance in material school-to-work transition outcomes situated at the cluster level. The VPC serves as a measure of the *discriminatory accuracy* of the intersectional strata, highlighting the extent to which intersecting social categories of parental social class, gender, migration background, and educational track are relevant in influencing material outcomes of German school-to-work transitions (**RQ1**). Furthermore, *predicted average strata-specific outcomes* are computed to pinpoint specific intersectional social positions in which inequalities in job security and early career returns are most pronounced (**RQ3**)

Second, a *main effects* or *partially adjusted* specification is estimated, including the social categories of substantive interest, that is, *parental social class*, *gender*, *migration background*, and *educational track*, as fixed effects. The random effects, or strata-level residuals for either outcome variable represent intersectional effects, measuring the unique multiplicative interaction associated with each intersectional social position, after controlling for the additive effects of belonging in a specific social category. This allows for identifying whether intersectional inequalities in job security and early career returns are statistically significant (**RQ3**). The adjusted VPC measures the strata-level variance that is due to multiplicative interaction effects only (**RQ2**). It is also possible to obtain the *Percentage Change in Variance* (PCV), measuring the extent to which between-strata differences in either outcome variable are explained by additive, rather than multiplicative effects (**RQ2**).

All models are computed with the `brm_multiple` command, which automatically obtains point estimates for every coefficient by combining the posterior probability draws from each of the 50 complete data sets imputed with MICE [@zhou_note_2010].

To start, two custom helper functions are specified, to aid in efficiently managing the memory utilised by R when executing computationally complex estimations with `brms` and `tidybayes`.

First, `run_predictions` is designed, a custom function checking whether predicted or expected values for the outcome of interest are already saved in the machine, or if they must be estimated and stored in memory.

Second, `run_ranef` is designed, a custom function checking whether random or intersectional effects for the outcome of interest are already saved in the machine, or if they must be estimated and stored in memory.

The main reason why these custom helper functions are necessary is the computational complexity of the `add_epred_draws` and `ranef` commands, loaded into the environment from the `tidybayes` and `brms` packages, respectively. Avoiding to execute these estimations every time the Quarto project is run or compiled saves a lot of time and space in memory.

```{r}
# Custom function to check whether predicted or expected values for the outcome of interest are already saved in the machine, or if they must be estimated and stored in memory.  

# Parameters:
# expr: the expression to be evaluated from the function, in practice the operations carried out with add_epred_draws. 
# path: character string containing the path where the results of the expression are already saved, or must be stored if the file does not exist yet.
# reuse: a boolean parameter, set to TRUE as default, specifying that the function should first try to load existing predictions from the indicated path, before re-evaluating expr.

run_predictions <- function(expr, path, reuse = TRUE) {
  
  # Attaching the ".rds" to the path character string.
  path <- paste0(path, ".rds")
  
  # The function tries to load existing predictions by default.
  if (reuse) {
    result <- suppressWarnings(try(readRDS(path), silent = TRUE))
    
    # If an error is returned, then the results of the expression are not already saved, and should be stored in memory with saveRDS.
    if (is(result, "try-error")) {
    result <- eval(expr)
    saveRDS(result, file = path, compress = "gzip")
    }
    
    # If no error is returned, then a message is printed, informing that the predicted or expected values are already saved in memory.
    else {
      print(
        "The predicted or expected values are already saved in memory.")
    }
  }
}
  
# Custom function to check whether random or intersectional effects for the outcome of interest are already saved in the machine, or if they must be estimated and stored in memory.  

# Parameters:
# expr: the expression to be evaluated from the function, in practice the operations carried out with ranef. 
# path: character string containing the path where the results of the expression are already saved, or must be stored if the file does not exist yet.
# reuse: a boolean parameter, set to TRUE as default, specifying that the function should first try to load existing random or intersectional effects from the indicated path, before re-evaluating expr.

run_ranef <- function(expr, path, reuse = TRUE) {
  
  # Attaching the ".rds" to the path character string.
  path <- paste0(path, ".rds")
  
  # The function tries to load existing random effects by default.
  if (reuse) {
    result <- suppressWarnings(try(readRDS(path), silent = TRUE))
    
    # If an error is returned, then the results of the expression are not already saved, and should be stored in memory with saveRDS.
    if (is(result, "try-error")) {
    result <- eval(expr)
    saveRDS(result, file = path, compress = "gzip")
    }
    
    # If no error is returned, then a message is printed, informing that the predicted or expected values are already saved in memory.
    else {
      print("The random effects are already saved in memory.")
    }
  }
}
```

### 4.1 ✧ Job security: partitioning within-strata and between-strata variance

The null specification for job security, measured by the probability of being employed under a permanent contract is the first to be estimated. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the null specification for probability of being employed under a permanent contract.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

empty_cont4_main <- brm_multiple(y9_w_cont4 ~ 1 + (1|strata),
                                 data = imp_main,
                                 warmup = 5000,
                                 iter = 10000,
                                 chains = 8,
                                 seed = 420,
  file = "Data/Many Intersections in Search of an Author/empty_cont4_main",
                                 file_compress = "gzip",
                                 file_refit = "never"
)

# Ending the timer for the estimation or loading of the null specification for probability of being employed under a permanent contract.
toc()
```

The summary for the null specification for job security is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table 3*.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(empty_cont4_main))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(empty_cont4_main$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 3*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_cont4_main)$strata$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 3*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_cont4_main)$residual__$sd[1]^2
```

The VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table 3*.

```{r}
# Rounding to the second decimal place when reporting the VPC.
round(
  (VarCorr(empty_cont4_main)$strata$sd[1]^2 /
   (VarCorr(empty_cont4_main)$strata$sd[1]^2 +
      VarCorr(empty_cont4_main)$residual__$sd[1]^2)
   ) * 100, 2
)
```

Throughout the study, all predicted and expected values are drawn from the imputed analytic sample number 42, which is [The Answer to Life, the Universe, and Everything](https://news.mit.edu/2019/answer-life-universe-and-everything-sum-three-cubes-mathematics-0910).

Kay [-@kay_tidybayes_2023] strongly advises against selecting a small sample of `ndraws` when deriving predicted and expected probabilities from Bayesian multilevel models. However, due to computational limitations, I am forced to extract a subsample of 10000 posterior draws. This may introduce minor bias in the estimates for predicted and expected probabilities of being employed under a permanent contract and net monthly incomes.

Predicted average strata-specific outcomes in probability of being employed under a permanent contract are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A3* in the Appendix.

```{r}
# Setting the analytic sample on which all predictions are based.
imp_pred <- imp_main[[42]]

# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  empty_cont4_main |> add_epred_draws(newdata = imp_pred,
                                      ndraws = 10000) |>
    # Computing means of predicted values across intersectional strata.
    group_by(strata) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/pred_empty_cont4_main"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory.

```{r, include = FALSE}
# Releasing the unused memory to keep the environment clean.
gc()
```

Then, the partially adjusted specification for job security is computed. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the partially adjusted specification for probability of being employed under a permanent contract.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

# adapt_delta is increased to 0.99 to decrease step size and offset the risk of convergence issues, in the form of divergent transitions.

adj_cont4_main <- brm_multiple(y9_w_cont4 ~ 1 + y9_hisei + y9_sex +
                               y9_generationG + y9_hgendeg + (1|strata),
                               data = imp_main,
                               warmup = 5000,
                               iter = 10000,
                               chains = 8,
                               seed = 420,
                               control = list(adapt_delta = 0.99),
  file = "Data/Many Intersections in Search of an Author/adj_cont4_main",
                               file_compress = "gzip",
                               file_refit = "never"
)

# Ending the timer for the estimation or loading of the partially adjusted specification for probability of being employed under a permanent contract.
toc()
```

The summary for the partially adjusted specification for job security is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table 3*.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(adj_cont4_main))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(adj_cont4_main$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 3*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_cont4_main)$strata$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 3*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_cont4_main)$residual__$sd[1]^2
```

The adjusted VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table 3*.

```{r}
# Rounding to the second decimal place when reporting the adjusted VPC.
round(
  (VarCorr(adj_cont4_main)$strata$sd[1]^2 /
   (VarCorr(adj_cont4_main)$strata$sd[1]^2 +
      VarCorr(adj_cont4_main)$residual__$sd[1]^2)
   ) * 100, 2
)
```

The PCV is calculated by dividing the difference between the null between-strata variance and the partially adjusted between-strata variance by the null between-strata variance, and then reported into *Table 3*.

```{r}
# Rounding to the second decimal place when reporting the PCV.
round(
  (VarCorr(empty_cont4_main)$strata$sd[1]^2 -
   VarCorr(adj_cont4_main)$strata$sd[1]^2) /
      VarCorr(empty_cont4_main)$strata$sd[1]^2 * 100, 2
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the null specification for job security is removed.

```{r, include = FALSE}
# Removing the null specification for job security to keep the environment clean.
rm(empty_cont4_main)

# Releasing the unused memory to keep the environment clean.
gc()
```

Predicted and expected average strata-specific outcomes in probability of being employed under a permanent contract are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A3* in the Appendix. Predicted values account for fixed and random effects, while expected values only account for fixed effects, without the intersectional between-strata residuals.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  adj_cont4_main |> add_epred_draws(newdata = imp_pred,
                                    ndraws = 10000) |>
    # Computing means of predicted values across intersectional strata.
    group_by(strata) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/pred_adj_cont4_main"
)

# Calling the custom run_prediction function to draw the expected values.
run_predictions(
  adj_cont4_main |> add_epred_draws(newdata = imp_pred,
                                    ndraws = 10000,
                                    # Random effects are factored out.
                                    re_formula = NA) |>
    # Computing means of expected values across intersectional strata.
    group_by(strata) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/exp_adj_cont4_main"
)
```

Intersectional or random effects in probability of being employed under a permanent contract are computed with the `ranef` function loaded from `brms`, thanks to the `run_ranef` custom helper function, and reported in *Table A3* in the Appendix.

```{r}
run_ranef(as_tibble(ranef(adj_cont4_main)$strata) |>
            # Rounding to the fourth decimal place.
            round(4) |> rowwise() |>
            # Assigning strata IDs to each random effect.
            mutate(strata = cur_group_id()) |> relocate(strata),
  path = 
    "Data/Many Intersections in Search of an Author/ranef_adj_cont4_main"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the partially adjusted specification for job security is removed.

```{r, include = FALSE}
# Removing the partially adjusted specification for job security to keep the environment clean.
rm(adj_cont4_main)

# Releasing the unused memory to keep the environment clean.
gc()
```

### 4.2 ✧ Early career returns: partitioning within-strata and between-strata variance

The null specification for early career returns, measured by net monthly income, is the first to be estimated. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the null specification for net monthly income.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

empty_incCS_main <- brm_multiple(y9_w_incCS ~ 1 + (1|strata),
                                 data = imp_main,
                                 warmup = 5000,
                                 iter = 10000,
                                 chains = 8,
                                 seed = 420,
  file = "Data/Many Intersections in Search of an Author/empty_incCS_main",
                                 file_compress = "gzip",
                                 file_refit = "never"
)

# Ending the timer for the estimation or loading of the null specification for net monthly income.
toc()
```

The summary for the null specification for early career returns is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table 4*.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(empty_incCS_main))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(empty_incCS_main$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 4*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_incCS_main)$strata$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 4*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_incCS_main)$residual__$sd[1]^2
```

The VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table 4*.

```{r}
# Rounding to the second decimal place when reporting the VPC.
round(
  (VarCorr(empty_incCS_main)$strata$sd[1]^2 /
   (VarCorr(empty_incCS_main)$strata$sd[1]^2 +
      VarCorr(empty_incCS_main)$residual__$sd[1]^2)
   ) * 100, 2
)
```

Predicted average strata-specific outcomes in net monthly income are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A4* in the Appendix.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  empty_incCS_main |> add_epred_draws(newdata = imp_pred,
                                      ndraws = 10000) |>
  group_by(strata) |> mean_qi(.epred),
  # Computing means of predicted values across intersectional strata.
  path = 
    "Data/Many Intersections in Search of an Author/pred_empty_incCS_main"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory.

```{r, include = FALSE}
# Releasing the unused memory to keep the environment clean.
gc()
```

Then, the partially adjusted specification for early career returns is computed. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the partially adjusted specification for net monthly income.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

# adapt_delta is increased to 0.9999 to decrease step size and offset the risk of convergence issues, in the form of divergent transitions.

# max_treedepth is also raised to 12, to avoid the No U-Turn (NUTS) sampler interrupting the Hamiltonian Monte Carlo (HMC) simulation before it reaches convergence with this smaller step size.

adj_incCS_main <- brm_multiple(y9_w_incCS ~ 1 + y9_hisei + y9_sex +
                               y9_generationG + y9_hgendeg + (1|strata),
                               data = imp_main,
                               warmup = 5000,
                               iter = 10000,
                               chains = 8,
                               seed = 420,
                               control = list(adapt_delta = 0.9999,
                                              max_treedepth = 12),
  file = "Data/Many Intersections in Search of an Author/adj_incCS_main",
                               file_compress = "gzip",
                               file_refit = "never"
)

# Ending the timer for the estimation or loading of the partially adjusted specification for net monthly income.
toc()
```

The summary for the partially adjusted specification for early career returns is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table 4*.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(adj_incCS_main))

```

Minor convergence issues arise in the partially adjusted specification for early career returns, with a single *divergent transition* ensuing despite decreasing the step size of the *Hamiltonian Monte Carlo* (HMC) algorithm used by the `brms` No U-Turn Sampler (NUTS) [@betancourt_conceptual_2017]. More information on divergent transitions and how to deal with them, in increasing level of technical complexity, can be found [here](https://ourcodingclub.github.io/tutorials/brms/), [here](https://betanalpha.github.io/assets/case_studies/identifiability.html), and [here](https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup).

To evaluate whether this single transition signals broader reliability issues in estimation and statistical inference, *parallel coordinates plots* must be generated for each substantively relevant predictor. These are *Figure A1*, *Figure A2*, and *Figure A3* in the Appendix. Predictors were distributed across figures based on their numeric ranges, so as to make the plots more easily interpretable.

```{r}
# Extracting the posterior samples estimated by the brms model (imputed dataset 6) containing the divergent transition.
posterior_samples <- as_draws_df(
  adj_incCS_main$fit)[((5*40000) + 1):(6*40000 ), ]

# Extracting the NUTS sampler diagnostics from the brms model (imputed dataset 6) containing the divergent transition.
nuts_diagnostics <- rstan::get_sampler_params(
  adj_incCS_main$fit, inc_warmup = FALSE)[41:48]

# Saving the posterior draws for the intercept and between-strata variance into a tibble.
parameters_a1 <- suppressWarnings(
  as.data.frame(as.matrix(posterior_samples |>
                            select(b_Intercept, sigma)
                          ))) |>
  mutate(divergent = case_when(
    # Signaling the divergent transition (1) based on the NUTS sampler diagnostics.
    row_number() %in% which(sapply(nuts_diagnostics,
                                   function(x) x[, "divergent__"]
                                   ) == 1) ~ 1,
    TRUE ~ 0
  ),
  
  # Setting the iteration number for each posterior draw.
  iteration = 1:n()
  ) |>
  # Pivoting the tibble to a longer format for easier plotting.
  pivot_longer(cols = -c(iteration, divergent),
               names_to = "parameter", values_to = "value")

# Saving the posterior draws for the fixed effects into a tibble.
parameters_a2 <- suppressWarnings(
  as.data.frame(as.matrix(posterior_samples |>
                            select(b_y9_hiseiMiddleMclass,
                                   b_y9_hiseiUpperMclass,
                                   b_y9_sexWoman,
                                   b_y9_generationGYes,
                                   b_y9_hgendegVocational)
                          ))) |>
  mutate(
    # Signaling the divergent transition (1) based on the NUTS sampler diagnostics.
    divergent = case_when(
    row_number() %in% which(sapply(nuts_diagnostics,
                                   function(x) x[, "divergent__"]
                                   ) == 1) ~ 1,
    TRUE ~ 0
    ),
    
    # Setting the iteration number for each posterior draw.
    iteration = 1:n()) |>
  # Pivoting the tibble to a longer format for easier plotting.
  pivot_longer(cols = -c(iteration, divergent),
               names_to = "parameter", values_to = "value")

# Saving the posterior draws for the random effects into a tibble.
parameters_a3 <- suppressWarnings(
  as.data.frame(as.matrix(posterior_samples |>
                            select(-b_Intercept, -Intercept, -sigma,
                                   -.chain, -lp__, -lprior,
                                   -.iteration, -.draw,
                                   -b_y9_hiseiMiddleMclass,
                                   -b_y9_hiseiUpperMclass,
                                   -b_y9_sexWoman,
                                   -b_y9_generationGYes,
                                   -b_y9_hgendegVocational)
                          ))) |>
  mutate(
    # Signaling the divergent transition (1) based on the NUTS sampler diagnostics.
    divergent = case_when(
    row_number() %in% which(sapply(nuts_diagnostics,
                                   function(x) x[, "divergent__"]
                                   ) == 1) ~ 1,
    TRUE ~ 0
    ),
    
    # Setting the iteration number for each posterior draw.
    iteration = 1:n()) |>
  # Pivoting the tibble to a longer format for easier plotting.
  pivot_longer(cols = -c(iteration, divergent),
               names_to = "parameter", values_to = "value")
  
# Creating Figure A1 by plotting separate parallel coordinates for the non-divergent transitions and the divergent transition with different colours (color) and transparencies (alpha).

figurea1 <- ggplot() +
  geom_line(data = parameters_a1 |> filter(divergent == FALSE),
            aes(x = parameter, y = value, group = iteration,
                color = "Non-Divergent Transition"),
            alpha = 0.2) +
  geom_line(data = parameters_a1 |> filter(divergent == TRUE),
            aes(x = parameter, y = value, group = iteration,
                color = "Divergent Transition"),
            linewidth = 1, alpha = 0.8) +
  xlab("Parameter") + ylab("Estimate (€)") +
  theme_bw() +
  ggtitle(
    "Figure A1 – Parallel Coordinates Plot for Estimates of Intercepts\n and Residual Standard Deviations (σₑ₀) yielded by Imputed Dataset 6\nin the Partially Adjusted Main Model of Net Monthly Income (€)"
  ) +
  theme(
    axis.title.x = element_text(size = 13),
    axis.title.y = element_text(size = 13),
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_text(size = 11.5),
    axis.text.y = element_text(size = 11.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5),
  ) +
  scale_y_continuous(breaks = seq(300, 2200, 100)) +
  scale_x_discrete(labels = c("Intercept",
                              "Residual Standard Deviation (σₑ₀)")) +
  scale_color_manual(values = c("Non-Divergent Transition" = "#2C302E",
                                "Divergent Transition" = "#FB4B4E")) +
  labs(color = "")

# Creating Figure A2 by plotting separate parallel coordinates for the non-divergent transitions and the divergent transition with different colours (color) and transparencies (alpha).

figurea2 <- ggplot() +
  geom_line(data = parameters_a2 |> filter(divergent == FALSE),
            aes(x = parameter, y = value, group = iteration,
                color = "Non-Divergent Transition"),
            alpha = 0.2) +
  geom_line(data = parameters_a2 |> filter(divergent == TRUE),
            aes(x = parameter, y = value, group = iteration,
                color = "Divergent Transition"),
            linewidth = 1, alpha = 0.8) +
  xlab("Parameter") + ylab("Estimate (€)") +
  theme_bw() +
  ggtitle(
    "Figure A2 – Parallel Coordinates Plot for Estimates\nof Main Effects yielded by Imputed Dataset 6 in the\nPartially Adjusted Main Model of Net Monthly Income (€)"
    ) +
  theme(
    axis.title.x = element_text(size = 13),
    axis.title.y = element_text(size = 13),
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_text(size = 11.5),
    axis.text.y = element_text(size = 11.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5),
    ) + scale_y_continuous(breaks = seq(-300, 300, 25)) +
  scale_x_discrete(labels = c(
    "Migration Background:\n>=1 Grandparent non-German-born",
    "Educational Track:\nVocational",
    "Parental Social Class:\nMiddle-class",
    "Parental Social Class:\nUpper-class",
    "Gender: Woman"))  +
  scale_color_manual(values = c("Non-Divergent Transition" = "#2C302E",
                                "Divergent Transition" = "#FB4B4E")) +
  labs(color = "")

# Creating Figure A3 by plotting separate parallel coordinates for the non-divergent transitions and the divergent transition with different colours (color) and transparencies (alpha).

figurea3 <- ggplot() +
  geom_line(data = parameters_a3 |> filter(divergent == FALSE),
            aes(x = parameter, y = value, group = iteration,
                color = "Non-Divergent Transition"),
            alpha = 0.2) +
  geom_line(data = parameters_a3 |> filter(divergent == TRUE),
            aes(x = parameter, y = value, group = iteration,
                color = "Divergent Transition"),
            linewidth = 1, alpha = 0.8) +
  xlab("Parameter") + ylab("Estimate (€)") +
  theme_bw() +
  ggtitle("Figure A3 – Parallel Coordinates Plot for Estimates\nof Random Effects yielded by Imputed Dataset 6 in the\nPartially Adjusted Main Model of Net Monthly Income (€)") +
  theme(
    axis.title.x = element_text(size = 13),
    axis.title.y = element_text(size = 13),
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_text(angle = 90, size = 11.5),
    axis.text.y = element_text(size = 11.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5),
    ) + scale_y_continuous(breaks = seq(-300, 300, 25)) +
  scale_x_discrete(labels = c("Stratum 1: Random Intercept (μ₀₁)",
                              "Stratum 10: Random Intercept (μ₀₁₀)",
                              "Stratum 11: Random Intercept (μ₀₁₁)",
                              "Stratum 12: Random Intercept (μ₀₁₂)",
                              "Stratum 13: Random Intercept (μ₀₁₃)",
                              "Stratum 14: Random Intercept (μ₀₁₄)",
                              "Stratum 15: Random Intercept (μ₀₁₅)",
                              "Stratum 16: Random Intercept (μ₀₁₆)",
                              "Stratum 17: Random Intercept (μ₀₁₇)",
                              "Stratum 18: Random Intercept (μ₀₁₈)",
                              "Stratum 19: Random Intercept (μ₀₁₉)",
                              "Stratum 2: Random Intercept (μ₀₂)",
                              "Stratum 20: Random Intercept (μ₀₂₀)",
                              "Stratum 21: Random Intercept (μ₀₂₁)",
                              "Stratum 22: Random Intercept (μ₀₂₂)",
                              "Stratum 23: Random Intercept (μ₀₂₃)",
                              "Stratum 24: Random Intercept (μ₀₂₄)",
                              "Stratum 3: Random Intercept (μ₀₃)",
                              "Stratum 4: Random Intercept (μ₀₄)",
                              "Stratum 5: Random Intercept (μ₀₅)",
                              "Stratum 6: Random Intercept (μ₀₆)",
                              "Stratum 7: Random Intercept (μ₀₇)",
                              "Stratum 8: Random Intercept (μ₀₈)",
                              "Stratum 9: Random Intercept (μ₀₉)",
                              expression(
         "Between-strata Standard Deviation ("*sigma[strata]*")")
                              )) +
  scale_color_manual(values = c("Non-Divergent Transition" = "#2C302E",
                                "Divergent Transition" = "#FB4B4E")) +
  labs(color = "")

# Saving Figures A1, A2, and A3 as .png images.

# Figure A1.
ggsave(filename = "Tables & Figures/figurea1.png",
       plot = figurea1, width = 10, height = 8, dpi = 300)

# Figure A2.
ggsave(filename = "Tables & Figures/figurea2.png",
       plot = figurea2, width = 10, height = 8, dpi = 300)

# Figure A3.
ggsave(filename = "Tables & Figures/figurea3.png",
       plot = figurea3, width = 10, height = 8, dpi = 300)
```

As reported in the study, the degeneracy in the single divergent transition corresponds to an anomalous fixed effects coefficient for women, but all figures show that the computation of other parameters is not affected. Since the Gelman-Rubin diagnostics also indicate strong convergence, the resulting estimators should not be subjected to substantial bias.

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the posterior samples, NUTS diagnostics, and estimates and plots for Figures A1, A2, and A3 are removed.

```{r, include = FALSE}
# Removing the posterior samples, NUTS diagnostics, and estimates and plots for Figures A1, A2, and A3 to keep the environment clean.
rm(posterior_samples, nuts_diagnostics,
   parameters_a1, parameters_a2, parameters_a3,
   figurea1, figurea2, figurea3)

# Releasing the unused memory to keep the environment clean.
gc()
```

For the sake of transparency, the NUTS sampler diagnostics for the posterior draw corresponding to the divergent transition are extracted and reported in *Table A5* in the Appendix.

```{r}
# Extracting the nuts parameters from the partially adjusted model for early career returns.
brms::nuts_params(adj_incCS_main) |>
  # Selecting the chain and iteration with the divergent transition.
  filter(Chain == 42) |> filter(Iteration == 888) |>
  # Reporting substantively relevant NUTS sampler parameters, rounding them to the third decimal place.
  filter(Parameter != "divergent__") |>
  select(Parameter, Value) |>
  mutate(Value = round(as.numeric(Value), 3),
         Parameter = case_when(
           Parameter == "accept_stat__" ~ "Acceptance Statistic",
           Parameter == "stepsize__" ~ "Step Size",
           Parameter == "treedepth__" ~ "Tree Depth",
           Parameter == "n_leapfrog__" ~ "Number of Leapfrog Steps",
           Parameter == "energy__" ~ "Energy",
           TRUE ~ Parameter
         ))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(adj_incCS_main$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 4*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_incCS_main)$strata$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table 4*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_incCS_main)$residual__$sd[1]^2
```

The adjusted VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table 4*.

```{r}
# Rounding to the second decimal place when reporting the adjusted VPC.
round(
  (VarCorr(adj_incCS_main)$strata$sd[1]^2 /
   (VarCorr(adj_incCS_main)$strata$sd[1]^2 +
      VarCorr(adj_incCS_main)$residual__$sd[1]^2)
   ) * 100, 2
)
```

The PCV is calculated by dividing the difference between the null between-strata variance and the partially adjusted between-strata variance by the null between-strata variance, and then reported into *Table 4*.

```{r}
# Rounding to the second decimal place when reporting the PCV.
round(
  (VarCorr(empty_incCS_main)$strata$sd[1]^2 -
   VarCorr(adj_incCS_main)$strata$sd[1]^2) /
      VarCorr(empty_incCS_main)$strata$sd[1]^2 * 100, 2
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the null specification for early career returns is removed.

```{r, include = FALSE}
# Removing the null specification for early career returns to keep the environment clean.
rm(empty_incCS_main)

# Releasing the unused memory to keep the environment clean.
gc()
```

Predicted and expected average strata-specific outcomes in net monthly income are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A4* in the Appendix. Predicted values account for fixed and random effects, while expected values only account for fixed effects, without the intersectional between-strata residuals.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  adj_incCS_main |> add_epred_draws(newdata = imp_pred,
                                    ndraws = 10000) |>
    # Computing means of predicted values across intersectional strata.
    group_by(strata) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/pred_adj_incCS_main"
)

# Calling the custom run_prediction function to draw the expected values.
run_predictions(
  adj_incCS_main |> add_epred_draws(newdata = imp_pred,
                                    ndraws = 10000,
                                    # Random effects are factored out.
                                    re_formula = NA) |>
    # Computing means of expected values across intersectional strata.
    group_by(strata) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/exp_adj_incCS_main"
)
```

Intersectional or random effects in net monthly income are computed with the `ranef` function loaded from `brms`, thanks to the `run_ranef` custom helper function, and reported in *Table A4* in the Appendix.

```{r}
run_ranef(as_tibble(ranef(adj_incCS_main)$strata) |>
            # Rounding to the fourth decimal place.
            round(4) |> rowwise() |>
            # Assigning strata IDs to each random effect.
            mutate(strata = cur_group_id()) |> relocate(strata),
  path = 
    "Data/Many Intersections in Search of an Author/ranef_adj_incCS_main"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the partially adjusted specification for early career returns is removed.

```{r, include = FALSE}
# Removing the partially adjusted specification for early career returns to keep the environment clean.
rm(adj_incCS_main)

# Releasing the unused memory to keep the environment clean.
gc()
```

### 4.3 ✧ Visualizing predicted values for each intersectional stratum

After having estimated the null and partially adjusted specifications, as well as predicted and expected values, the next step in intersectional MAIHDA is reporting predicted values, expected values, and random effects for each applicable model across intersectional strata. Importantly, this involves *visualising predicted values for each outcome of interest in the null specification*, to display how unadjusted VPCs capture meaningful inequalities in job security and early career returns. Furthermore, predicted average strata-specific outcomes serve to highlight specific intersectional social positions in which disparities in material outcomes of school-to-work transitions are most pronounced.

Foremost, it is necessary to import predicted values, expected values, and random effects in the null and partially adjusted specifications for *probability of being employed under a permanent contract*. In line with the recommendations of Keller and colleagues [-@keller_educational_2023], these objects are reloaded into the environment when necessary, due to the computational complexity of their estimation.

```{r}
# Loading predicted values in the null specification.
pred_empty_cont4_main <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_empty_cont4_main.rds")

# Loading expected values in the partially adjusted specification.
exp_adj_cont4_main <- readRDS(file = "Data/Many Intersections in Search of an Author/exp_adj_cont4_main.rds")

# Loading predicted values in the partially adjusted specification.
pred_adj_cont4_main <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_adj_cont4_main.rds")

# Loading the random effects.
ranef_adj_cont4_main <- readRDS(file = "Data/Many Intersections in Search of an Author/ranef_adj_cont4_main.rds")
```

Detailed information on strata sample sizes, predicted and expected values, and random effects across intersectional strata is tidied and reported in *Table A3* in the Appendix.

```{r}
# Renaming, selecting, and joining predicted and expected values and random effects by intersectional stratum.

tablea3 <- pred_empty_cont4_main |> rename(
  pred_empty = .epred, pred_empty_lower = .lower,
  pred_empty_upper = .upper
) |> select(-.width, -.point, -.interval) |>
  inner_join(exp_adj_cont4_main |>
               rename(
                 exp_adj = .epred, exp_adj_lower = .lower,
                 exp_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata"
             ) |> inner_join(pred_adj_cont4_main |>
               rename(
                 pred_adj = .epred, pred_adj_lower = .lower,
                 pred_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata"
             ) |> inner_join(ranef_adj_cont4_main |>
               rename(
                 ranef = Estimate.Intercept,
                 ranef_lower = Q2.5.Intercept,
                 ranef_upper = Q97.5.Intercept
                 ) |> select(-Est.Error.Intercept),
             by = "strata"
             # Rounding every figure at least to the fourth decimal place.
             ) |> round(4) |>
  # Joining intersectional strata indicators of parental social class, gender, migration background, and educational track, as well as strata sample sizes.
  inner_join(readRDS(file = "Data/Many Intersections in Search of an Author/imp_main")[[42]] |>
               select(strata, y9_hisei, y9_sex,
                      y9_generationG, y9_hgendeg,
                      count) |>
               group_by(strata) |> slice_head() |> ungroup(),
             by = "strata") |>
  relocate(strata, count, y9_hisei, y9_sex, y9_generationG, y9_hgendeg)

# Table A3 is stored in memory with saveRDS.
saveRDS(tablea3, file = "Data/Many Intersections in Search of an Author/tablea3.rds", compress = "gzip")

# Removing all predicted and expected values and random effects to keep the environment clean.
rm(pred_empty_cont4_main, exp_adj_cont4_main,
   pred_adj_cont4_main, ranef_adj_cont4_main)

# Showing Table A3 and reporting it into the Appendix.
tablea3
```

Then, it is necessary to import predicted values, expected values, and random effects in the null and partially adjusted specifications for *net monthly income*. In line with the recommendations of Keller and colleagues [-@keller_educational_2023], these objects are reloaded into the environment when necessary, due to the computational complexity of their estimation.

```{r}
# Loading predicted values in the null specification.
pred_empty_incCS_main <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_empty_incCS_main.rds")

# Loading expected values in the partially adjusted specification.
exp_adj_incCS_main <- readRDS(file = "Data/Many Intersections in Search of an Author/exp_adj_incCS_main.rds")

# Loading predicted values in the partially adjusted specification.
pred_adj_incCS_main <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_adj_incCS_main.rds")

# Loading the random effects.
ranef_adj_incCS_main <- readRDS(file = "Data/Many Intersections in Search of an Author/ranef_adj_incCS_main.rds")
```

Detailed information on strata sample sizes, predicted and expected values, and random effects across intersectional strata is tidied and reported in *Table A4* in the Appendix.

```{r}
# Renaming, selecting, and joining predicted and expected values and random effects by intersectional stratum.

tablea4 <- pred_empty_incCS_main |> rename(
  pred_empty = .epred, pred_empty_lower = .lower,
  pred_empty_upper = .upper
) |> select(-.width, -.point, -.interval) |>
  inner_join(exp_adj_incCS_main |>
               rename(
                 exp_adj = .epred, exp_adj_lower = .lower,
                 exp_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata"
             ) |> inner_join(pred_adj_incCS_main |>
               rename(
                 pred_adj = .epred, pred_adj_lower = .lower,
                 pred_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata"
             ) |> inner_join(ranef_adj_incCS_main |>
               rename(
                 ranef = Estimate.Intercept,
                 ranef_lower = Q2.5.Intercept,
                 ranef_upper = Q97.5.Intercept
                 ) |> select(-Est.Error.Intercept),
             by = "strata"
             # Rounding every figure at least to the fourth decimal place.
             ) |> round(4) |>
  # Joining intersectional strata indicators of parental social class, gender, migration background, and educational track, as well as strata sample sizes.
  inner_join(readRDS(file = "Data/Many Intersections in Search of an Author/imp_main")[[42]] |>
               select(strata, y9_hisei, y9_sex,
                      y9_generationG, y9_hgendeg,
                      count) |>
               group_by(strata) |> slice_head() |> ungroup(),
             by = "strata") |>
  relocate(strata, count, y9_hisei, y9_sex, y9_generationG, y9_hgendeg)

# Table A4 is stored in memory with saveRDS.
saveRDS(tablea4, file = "Data/Many Intersections in Search of an Author/tablea4.rds", compress = "gzip")

# Removing all predicted and expected values and random effects to keep the environment clean.
rm(pred_empty_incCS_main, exp_adj_incCS_main,
   pred_adj_incCS_main, ranef_adj_incCS_main)

# Showing Table A4 and reporting it into the Appendix.
tablea4
```

Predicted values for probability of being employed under a permanent contract in the null model are now visualised in *Figure 1*.

```{r}
# Migration background placeholders are set to their nominal values.
figure1 <- tablea3 |> 
   mutate(
    y9_generationG = case_when(
      y9_generationG == "No" ~ "All Grandparents\nGerman-born",
      y9_generationG == "Yes" ~ ">=1 Grandparent\nnon-German-born",
      TRUE ~ y9_generationG
    )
  ) |>
  ggplot(aes(x = pred_empty, y = y9_sex,
                                 color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = pred_empty_lower, xmax = pred_empty_upper)) +
  geom_point() +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generationG + y9_hgendeg) + 
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off") +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab("Predicted Mean Probability of being Employed under a Permanent Contract") +
  ylab("") +
  ggtitle("Figure 1 – Predicted Mean Probability of being Employed\nunder a Permanent Contract with 95% Credible Intervals\nin the Null Model across Intersectional Strata") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 10),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(0.65, 0.95, 0.01)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure 1 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figure1.png", plot = figure1,
       width = 10, height = 8, dpi = 300)
```

Predicted values for net monthly income in the null model are then visualised in *Figure 3*.

```{r}
# Migration background placeholders are set to their nominal values.
figure3 <- tablea4 |> 
   mutate(
    y9_generationG = case_when(
      y9_generationG == "No" ~ "All Grandparents\nGerman-born",
      y9_generationG == "Yes" ~ ">=1 Grandparent\nnon-German-born",
      TRUE ~ y9_generationG
    )
  ) |>
  ggplot(aes(x = pred_empty, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = pred_empty_lower, xmax = pred_empty_upper)) +
  geom_point() +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generationG + y9_hgendeg) + 
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off") +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab("Predicted Mean Net Monthly Income (€)") + ylab("") +
  ggtitle("Figure 3 – Predicted Mean Net Monthly Income (€) with 95% Credible Intervals\nin the Null Model across Intersectional Strata") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 10),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(1600, 2100, 25)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure 3 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figure3.png", plot = figure3,
       width = 10, height = 8, dpi = 300)
```

### 4.4 ✧ Visualising the residual random effects

Random effects for probability of being employed under a permanent contract in the null model are visualised in *Figure 2*, facilitating the systematic comparison of strata-level residuals across intersectional strata, representing the difference between values expected by the fixed effects and actual predicted values.

```{r}
# Migration background placeholders are set to their nominal values.
figure2 <- tablea3 |>
   mutate(
    y9_generationG = case_when(
      y9_generationG == "No" ~ "All Grandparents\nGerman-born",
      y9_generationG == "Yes" ~ ">=1 Grandparent\nnon-German-born",
      TRUE ~ y9_generationG
    )
  ) |>
  ggplot(aes(x = ranef, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = ranef_lower, xmax = ranef_upper)) +
  geom_point() +
  # A semi-transparent, jet black line is added to signal y = 0, to foster the interpretability of 95% credible intervals.
  geom_vline(xintercept = 0, color = "#2C302E",
             linetype = "solid", linewidth = 0.5, alpha = 0.5) +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generationG + y9_hgendeg) +
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off", xlim = c(-0.05, 0.05)) +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab(expression(mu[0][j])) + ylab("") +
  ggtitle(
    "Figure 2 – Interaction Effects for Probability of being\nEmployed Under a Permanent Contract (strata-level Residuals μ₀ⱼ)\nwith 95% Credible Intervals across Intersectional Strata") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 10),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(-0.05, 0.05, 0.005)) +
  scale_y_discrete(labels = c("Man", "Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure 2 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figure2.png", plot = figure2,
       width = 10, height = 8, dpi = 300)
```

Likewise, random effects for net monthly income are visualised in *Figure 4*, facilitating the systematic comparison of strata-level residuals across intersectional strata, representing the difference between values expected by the fixed effects and actual predicted values.

```{r}
# Migration background placeholders are set to their nominal values.
figure4 <- tablea4 |>
   mutate(
    y9_generationG = case_when(
      y9_generationG == "No" ~ "All Grandparents\nGerman-born",
      y9_generationG == "Yes" ~ ">=1 Grandparent\nnon-German-born",
      TRUE ~ y9_generationG
    )
  ) |>
  ggplot(aes(x = ranef, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = ranef_lower, xmax = ranef_upper)) +
  geom_point() +
  # A semi-transparent, jet black line is added to signal y = 0, to foster the interpretability of 95% credible intervals.
  geom_vline(xintercept = 0, color = "#2C302E",
             linetype = "solid", linewidth = 0.5, alpha = 0.5) +
  # The x and y coordinates are flipped for easier visualisation.
  facet_nested(~ y9_hisei + y9_generationG + y9_hgendeg) +
  coord_flip(clip = "off", xlim = c(-130, 130)) +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab(expression(""*(mu[0][j])*" (€)")) + ylab("") +
  ggtitle("Figure 4 – Interaction Effects for Net Monthly Income (€)\n(strata-level Residuals μ₀ⱼ) with 95% Credible Intervals across Intersectional Strata"
             ) +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 10),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(-130, 130, 10)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure 4 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figure4.png", plot = figure4,
       width = 10, height = 8, dpi = 300)
```

To conclude, the environment is cleaned from all remaining objects.

```{r, include = FALSE}
# Removing all tables and figures to keep the environment clean.
rm(tablea3, tablea4,
   figure1, figure2, figure3, figure4)

# Releasing the unused memory to keep the environment clean.
gc()
```

## 5. Robustness checks: testing a different operationalisation of migration background

Minor variations may be driven by potential generational differences between *foreign-born migrants* and *native-born descendants of migrants* arising in school-to-work transitions, emerging due to prolonged processes of integration in German educational institutions [@worbs_second_2003].

Thus, robustness checks are specified utilising a three-level categorical variable for *migration background*, distinguishing *foreign-born migrants* from *native-born descendants of migrants*. While small strata containing less than 10 individuals may exhibit minor but consistent negative bias, even under these circumstances, intersectional MAIHDA remains more accurate than conventional single-level frameworks [@van_dusen_comparing_2024].

### 5.1 ✧ Job security: partitioning within-strata and between-strata variance

The null specification for job security, measured by the probability of being employed under a permanent contract is the first to be estimated. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the null specification for probability of being employed under a permanent contract.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

empty_cont4_rob <- brm_multiple(y9_w_cont4 ~ 1 + (1|strata_rob),
                                 data = imp_main,
                                 warmup = 5000,
                                 iter = 10000,
                                 chains = 8,
                                 seed = 420,
  file = "Data/Many Intersections in Search of an Author/empty_cont4_rob",
                                 file_compress = "gzip",
                                 file_refit = "never"
)

# Ending the timer for the estimation or loading of the null specification for probability of being employed under a permanent contract.
toc()
```

The summary for the null specification for job security is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table A7* in the Appendix.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(empty_cont4_rob))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(empty_cont4_rob$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A7* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_cont4_rob)$strata_rob$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A7* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_cont4_rob)$residual__$sd[1]^2
```

The VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table A7*.

```{r}
# Rounding to the second decimal place when reporting the VPC.
round(
  (VarCorr(empty_cont4_rob)$strata_rob$sd[1]^2 /
   (VarCorr(empty_cont4_rob)$strata_rob$sd[1]^2 +
      VarCorr(empty_cont4_rob)$residual__$sd[1]^2)
   ) * 100, 2
)
```

Predicted average strata-specific outcomes in probability of being employed under a permanent contract are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A8* in the Appendix.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  empty_cont4_rob |> add_epred_draws(newdata = imp_pred,
                                     ndraws = 10000) |>
    # Computing means of predicted values across intersectional strata.
    group_by(strata_rob) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/pred_empty_cont4_rob"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory.

```{r, include = FALSE}
# Releasing the unused memory to keep the environment clean.
gc()
```

Then, the partially adjusted specification for job security is computed. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the partially adjusted specification for probability of being employed under a permanent contract.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

# adapt_delta is increased to 0.99 to decrease step size and offset the risk of convergence issues, in the form of divergent transitions.

adj_cont4_rob <- brm_multiple(y9_w_cont4 ~ 1 + y9_hisei + y9_sex +
                               y9_generation3 + y9_hgendeg +
                                (1|strata_rob),
                               data = imp_main,
                               warmup = 5000,
                               iter = 10000,
                               chains = 8,
                               seed = 420,
                               control = list(adapt_delta = 0.99),
  file = "Data/Many Intersections in Search of an Author/adj_cont4_rob",
                               file_compress = "gzip",
                               file_refit = "never"
)

# Ending the timer for the estimation or loading of the partially adjusted specification for probability of being employed under a permanent contract.
toc()
```

The summary for the partially adjusted specification for job security is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table A7* in the Appendix.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(adj_cont4_rob))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(adj_cont4_rob$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A7* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_cont4_rob)$strata_rob$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A7*.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_cont4_rob)$residual__$sd[1]^2
```

The adjusted VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table A7*.

```{r}
# Rounding to the second decimal place when reporting the adjusted VPC.
round(
  (VarCorr(adj_cont4_rob)$strata_rob$sd[1]^2 /
   (VarCorr(adj_cont4_rob)$strata_rob$sd[1]^2 +
      VarCorr(adj_cont4_rob)$residual__$sd[1]^2)
   ) * 100, 2
)
```

The PCV is calculated by dividing the difference between the null between-strata variance and the partially adjusted between-strata variance by the null between-strata variance, and then reported into *Table A7*.

```{r}
# Rounding to the second decimal place when reporting the PCV.
round(
  (VarCorr(empty_cont4_rob)$strata_rob$sd[1]^2 -
   VarCorr(adj_cont4_rob)$strata_rob$sd[1]^2) /
      VarCorr(empty_cont4_rob)$strata_rob$sd[1]^2 * 100, 2
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the null specification for job security is removed.

```{r, include = FALSE}
# Removing the null specification for job security to keep the environment clean.
rm(empty_cont4_rob)

# Releasing the unused memory to keep the environment clean.
gc()
```

Predicted and expected average strata-specific outcomes in probability of being employed under a permanent contract are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A8* in the Appendix. Predicted values account for fixed and random effects, while expected values only account for fixed effects, without the intersectional between-strata residuals.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  adj_cont4_rob |> add_epred_draws(newdata = imp_pred, 
                                   ndraws = 10000) |>
    # Computing means of predicted values across intersectional strata.
    group_by(strata_rob) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/pred_adj_cont4_rob"
)

# Calling the custom run_prediction function to draw the expected values.
run_predictions(
  adj_cont4_rob |> add_epred_draws(newdata = imp_pred,
                                   ndraws = 10000,
                                   # Random effects are factored out.
                                   re_formula = NA) |>
    # Computing means of expected values across intersectional strata.
    group_by(strata_rob) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/exp_adj_cont4_rob"
)
```

Intersectional or random effects in probability of being employed under a permanent contract are computed with the `ranef` function loaded from `brms`, thanks to the `run_ranef` custom helper function, and reported in *Table A8* in the Appendix.

```{r}
run_ranef(as_tibble(ranef(adj_cont4_rob)$strata_rob) |>
            # Rounding to the fourth decimal place.
            round(4) |> rowwise() |>
            # Assigning strata IDs to each random effect.
            mutate(strata_rob = cur_group_id()) |> relocate(strata_rob),
  path = 
    "Data/Many Intersections in Search of an Author/ranef_adj_cont4_rob"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the partially adjusted specification for job security is removed.

```{r, include = FALSE}
# Removing the partially adjusted specification for job security to keep the environment clean.
rm(adj_cont4_rob)

# Releasing the unused memory to keep the environment clean.
gc()
```

### 5.2 ✧ Early career returns: partitioning within-strata and between-strata variance

The null specification for early career returns, measured by net monthly income, is the first to be estimated. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the null specification for net monthly income.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

empty_incCS_rob <- brm_multiple(y9_w_incCS ~ 1 + (1|strata_rob),
                                 data = imp_main,
                                 warmup = 5000,
                                 iter = 10000,
                                 chains = 8,
                                 seed = 420,
  file = "Data/Many Intersections in Search of an Author/empty_incCS_rob",
                                 file_compress = "gzip",
                                 file_refit = "never"
)

# Ending the timer for the estimation or loading of the null specification for net monthly income.
toc()
```

The summary for the null specification for early career returns is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table A9* in the Appendix.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(empty_incCS_rob))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(empty_incCS_rob$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A9* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_incCS_rob)$strata_rob$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A9* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(empty_incCS_rob)$residual__$sd[1]^2
```

The VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table A9*.

```{r}
# Rounding to the second decimal place when reporting the VPC.
round(
  (VarCorr(empty_incCS_rob)$strata_rob$sd[1]^2 /
   (VarCorr(empty_incCS_rob)$strata_rob$sd[1]^2 +
      VarCorr(empty_incCS_rob)$residual__$sd[1]^2)
   ) * 100, 2
)
```

Predicted average strata-specific outcomes in net monthly income are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A10* in the Appendix.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  empty_incCS_rob |> add_epred_draws(newdata = imp_pred,
                                     ndraws = 10000) |>
  group_by(strata_rob) |> mean_qi(.epred),
  # Computing means of predicted values across intersectional strata.
  path = 
    "Data/Many Intersections in Search of an Author/pred_empty_incCS_rob"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory.

```{r, include = FALSE}
# Releasing the unused memory to keep the environment clean.
gc()
```

Then, the partially adjusted specification for early career returns is computed. Weakly informative, default priors are specified for all parameters, while computations are performed with eight `chains`, a `warmup` phase of 5000 iterations, and a total length of 10000 `iter`, or iterations.

```{r}
# Starting the timer for the estimation or loading of the partially adjusted specification for net monthly income.
tic()

# Setting a seed to ensure reproducibility and saving the file in the path indicated with the file option.

# The model is compressed with the gzip format, since its size is very large (≈1 GB) and never refitted when a file already exists in the specified path.

# adapt_delta is increased to 0.9999 to decrease step size and offset the risk of convergence issues, in the form of divergent transitions.

# max_treedepth is also raised to 12, to avoid the No U-Turn (NUTS) sampler interrupting the Hamiltonian Monte Carlo (HMC) simulation before it reaches convergence with this smaller step size.

adj_incCS_rob <- brm_multiple(y9_w_incCS ~ 1 + y9_hisei + y9_sex +
                               y9_generation3 + y9_hgendeg +
                                (1|strata_rob),
                               data = imp_main,
                               warmup = 5000,
                               iter = 10000,
                               chains = 8,
                               seed = 420,
                               control = list(adapt_delta = 0.9999,
                                              max_treedepth = 12),
  file = "Data/Many Intersections in Search of an Author/adj_incCS_rob",
                               file_compress = "gzip",
                               file_refit = "never"
)

# Ending the timer for the estimation or loading of the partially adjusted specification for net monthly income.
toc()
```

The summary for the partially adjusted specification for early career returns is then generated with the `summary` command, loaded into the environment from the `brms` package, generating the results reported in *Table A9* in the Appendix.

```{r}
# Warnings are suppressed because a bug in the brm_multiple command yields a false positive warning for convergence issues.
suppressWarnings(summary(adj_incCS_rob))
```

Model convergence is verified by means of the Gelman-Rubin diagnostic, or R [@gelman_inference_1992]. If R is markedly greater than 1, the chains have not converged and it is required to run more iterations, or set more informative priors [@burkner_brms_2017].

When utilising `brm_multiple`, the combined model issues false positive convergence warnings, as the MCMC chains corresponding to different datasets may not necessarily overlap, even if each of the original models did converge [@burkner_brms_2024]. To find out whether each of the original models converged, the `rhats` object within the output of `brm_multiple` should be investigated, by checking whether any of the `rhats` are equal to or greater than 1.01.

```{r}
any(round(adj_incCS_rob$rhats, 2) >= 1.01)
```

None of the `rhats` are equal to or greater than 1.01, indicating strong convergence. Next, the between-strata variance is extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A9* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_incCS_rob)$strata_rob$sd[1]^2
```

The residual, within-strata variance is similarly extracted by running the `VarCorr` method of the `brmsfit` model, and reported into *Table A9* in the Appendix.

```{r}
# brm_multiple estimates standard deviation instead of variances, so the parameter must be elevated to the power of 2.
VarCorr(adj_incCS_rob)$residual__$sd[1]^2
```

The adjusted VPC is calculated by dividing the between-strata variance by the sum of the between-strata and residual variance, and then reported into *Table A9*.

```{r}
# Rounding to the second decimal place when reporting the adjusted VPC.
round(
  (VarCorr(adj_incCS_rob)$strata$sd[1]^2 /
   (VarCorr(adj_incCS_rob)$strata$sd[1]^2 +
      VarCorr(adj_incCS_rob)$residual__$sd[1]^2)
   ) * 100, 2
)
```

The PCV is calculated by dividing the difference between the null between-strata variance and the partially adjusted between-strata variance by the null between-strata variance, and then reported into *Table A9*.

```{r}
# Rounding to the second decimal place when reporting the PCV.
round(
  (VarCorr(empty_incCS_rob)$strata_rob$sd[1]^2 -
   VarCorr(adj_incCS_rob)$strata_rob$sd[1]^2) /
      VarCorr(empty_incCS_rob)$strata_rob$sd[1]^2 * 100, 2
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the null specification for early career returns is removed.

```{r, include = FALSE}
# Removing the null specification for early career returns to keep the environment clean.
rm(empty_incCS_rob)

# Releasing the unused memory to keep the environment clean.
gc()
```

Predicted and expected average strata-specific outcomes in net monthly income are computed with the `add_epred_draws` function loaded from `tidybayes`, thanks to the `run_predictions` custom helper function, and reported in *Table A10* in the Appendix. Predicted values account for fixed and random effects, while expected values only account for fixed effects, without the intersectional between-strata residuals.

```{r}
# Calling the custom run_prediction function to draw the predicted values.
run_predictions(
  adj_incCS_rob |> add_epred_draws(newdata = imp_pred,
                                   ndraws = 10000) |>
  group_by(strata_rob) |> mean_qi(.epred),
  # Computing means of predicted values across intersectional strata.
  path = 
    "Data/Many Intersections in Search of an Author/pred_adj_incCS_rob"
)

# Calling the custom run_prediction function to draw the expected values.
run_predictions(
  adj_incCS_rob |> add_epred_draws(newdata = imp_pred,
                                   ndraws = 10000,
                                   # Random effects are factored out.
                                   re_formula = NA) |>
    # Computing means of expected values across intersectional strata.
  group_by(strata_rob) |> mean_qi(.epred),
  path = 
    "Data/Many Intersections in Search of an Author/exp_adj_incCS_rob"
)
```

Intersectional or random effects in net monthly income are computed with the `ranef` function loaded from `brms`, thanks to the `run_ranef` custom helper function, and reported in *Table A10* in the Appendix.

```{r}
run_ranef(as_tibble(ranef(adj_incCS_rob)$strata_rob) |>
            # Rounding to the fourth decimal place.
            round(4) |> rowwise() |>
            # Assigning strata IDs to each random effect.
            mutate(strata_rob = cur_group_id()) |> relocate(strata_rob),
  path = 
    "Data/Many Intersections in Search of an Author/ranef_adj_incCS_rob"
)
```

The working environment must be kept clean during execution, as objects derived from `brms` usually consume a lot of memory. Thus, the partially adjusted specification for early career returns is removed.

```{r, include = FALSE}
# Removing the partially adjusted specification for early career returns to keep the environment clean.
rm(adj_incCS_rob)

# Releasing the unused memory to keep the environment clean.
gc()
```

### 5.3 ✧ Visualizing predicted values for each intersectional stratum

After having estimated the null and partially adjusted specifications, as well as predicted and expected values, the next step in intersectional MAIHDA is reporting predicted values, expected values, and random effects for each applicable model across intersectional strata. Importantly, this involves *visualising predicted values for each outcome of interest in the null specification*, to display how unadjusted VPCs capture meaningful inequalities in job security and early career returns. Furthermore, predicted average strata-specific outcomes serve to highlight specific intersectional social positions in which disparities in material outcomes of school-to-work transitions are most pronounced.

Foremost, it is necessary to import predicted values, expected values, and random effects in the null and partially adjusted specifications for *probability of being employed under a permanent contract*.

```{r}
# Loading predicted values in the null specification.
pred_empty_cont4_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_empty_cont4_rob.rds")

# Loading expected values in the partially adjusted specification.
exp_adj_cont4_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/exp_adj_cont4_rob.rds")

# Loading predicted values in the partially adjusted specification.
pred_adj_cont4_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_adj_cont4_rob.rds")

# Loading the random effects.
ranef_adj_cont4_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/ranef_adj_cont4_rob.rds")
```

Detailed information on strata sample sizes, predicted and expected values, and random effects across intersectional strata is tidied and reported in *Table A8* in the Appendix.

```{r}
# Renaming, selecting, and joining predicted and expected values and random effects by intersectional stratum.

tablea8 <- pred_empty_cont4_rob |> rename(
  pred_empty = .epred, pred_empty_lower = .lower,
  pred_empty_upper = .upper
) |> select(-.width, -.point, -.interval) |>
  inner_join(exp_adj_cont4_rob |>
               rename(
                 exp_adj = .epred, exp_adj_lower = .lower,
                 exp_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata_rob"
             ) |> inner_join(pred_adj_cont4_rob |>
               rename(
                 pred_adj = .epred, pred_adj_lower = .lower,
                 pred_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata_rob"
             ) |> inner_join(ranef_adj_cont4_rob |>
               rename(
                 ranef = Estimate.Intercept,
                 ranef_lower = Q2.5.Intercept,
                 ranef_upper = Q97.5.Intercept
                 ) |> select(-Est.Error.Intercept),
             by = "strata_rob"
             # Rounding every figure at least to the fourth decimal place.
             ) |> round(4) |>
  # Joining intersectional strata indicators of parental social class, gender, migration background, and educational track, as well as strata sample sizes.
  inner_join(readRDS(file = "Data/Many Intersections in Search of an Author/imp_main")[[42]] |>
               select(strata_rob, y9_hisei, y9_sex,
                      y9_generation3, y9_hgendeg,
                      count_rob) |>
               group_by(strata_rob) |> slice_head() |> ungroup(),
             by = "strata_rob") |>
  relocate(strata_rob, count_rob,
           y9_hisei, y9_sex, y9_generation3, y9_hgendeg)

# Table A8 is stored in memory with saveRDS.
saveRDS(tablea8, file = "Data/Many Intersections in Search of an Author/tablea8.rds", compress = "gzip")

# Removing all predicted and expected values and random effects to keep the environment clean.
rm(pred_empty_cont4_rob, exp_adj_cont4_rob,
   pred_adj_cont4_rob, ranef_adj_cont4_rob)

# Showing Table A8 and reporting it into the Appendix.
tablea8
```

Then, it is necessary to import predicted values, expected values, and random effects in the null and partially adjusted specifications for *net monthly income*. In line with the recommendations of Keller and colleagues [-@keller_educational_2023], these objects are reloaded into the environment when necessary, due to the computational complexity of their estimation.

```{r}
# Loading predicted values in the null specification.
pred_empty_incCS_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_empty_incCS_rob.rds")

# Loading expected values in the partially adjusted specification.
exp_adj_incCS_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/exp_adj_incCS_rob.rds")

# Loading predicted values in the partially adjusted specification.
pred_adj_incCS_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/pred_adj_incCS_rob.rds")

# Loading the random effects.
ranef_adj_incCS_rob <- readRDS(file = "Data/Many Intersections in Search of an Author/ranef_adj_incCS_rob.rds")
```

Detailed information on strata sample sizes, predicted and expected values, and random effects across intersectional strata is tidied and reported in *Table A10* in the Appendix.

```{r}
# Renaming, selecting, and joining predicted and expected values and random effects by intersectional stratum.

tablea10 <- pred_empty_incCS_rob |> rename(
  pred_empty = .epred, pred_empty_lower = .lower,
  pred_empty_upper = .upper
) |> select(-.width, -.point, -.interval) |>
  inner_join(exp_adj_incCS_rob |>
               rename(
                 exp_adj = .epred, exp_adj_lower = .lower,
                 exp_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata_rob"
             ) |> inner_join(pred_adj_incCS_rob |>
               rename(
                 pred_adj = .epred, pred_adj_lower = .lower,
                 pred_adj_upper = .upper
                 ) |> select(-.width, -.point, -.interval),
             by = "strata_rob"
             ) |> inner_join(ranef_adj_incCS_rob |>
               rename(
                 ranef = Estimate.Intercept,
                 ranef_lower = Q2.5.Intercept,
                 ranef_upper = Q97.5.Intercept
                 ) |> select(-Est.Error.Intercept),
             by = "strata_rob"
             # Rounding every figure at least to the fourth decimal place.
             ) |> round(4) |>
  # Joining intersectional strata indicators of parental social class, gender, migration background, and educational track, as well as strata sample sizes.
  inner_join(readRDS(file = "Data/Many Intersections in Search of an Author/imp_main")[[42]] |>
               select(strata_rob, y9_hisei, y9_sex,
                      y9_generation3, y9_hgendeg,
                      count_rob) |>
               group_by(strata_rob) |> slice_head() |> ungroup(),
             by = "strata_rob") |>
  relocate(strata_rob, count_rob,
           y9_hisei, y9_sex, y9_generation3, y9_hgendeg)

# Table A10 is stored in memory with saveRDS.
saveRDS(tablea10, file = "Data/Many Intersections in Search of an Author/tablea10.rds", compress = "gzip")

# Removing all predicted and expected values and random effects to keep the environment clean.
rm(pred_empty_incCS_rob, exp_adj_incCS_rob,
   pred_adj_incCS_rob, ranef_adj_incCS_rob)

# Showing Table A10 and reporting it into the Appendix.
tablea10
```

Predicted values for probability of being employed under a permanent contract in the null model are now visualised in *Figure A4* in the Appendix.

```{r}
# Migration background placeholders are set to their nominal values.
figurea4 <- tablea8 |>
   mutate(
    y9_generation3 = case_when(
      y9_generation3 == "No, native-born" ~
        "All Grandparents\nGerman-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, native-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, foreign-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nForeign-born",
      TRUE ~ y9_generation3
    )
  ) |>
  ggplot(aes(x = pred_empty, y = y9_sex,
                                 color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = pred_empty_lower, xmax = pred_empty_upper)) +
  geom_point() +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generation3 + y9_hgendeg) + 
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off") +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab("Predicted Mean Probability of being Employed under a Permanent Contract") +
  ylab("") +
  ggtitle("Figure A4 – Predicted Mean Probability of being Employed under a\nPermanent Contract with 95% Credible Intervals in the Null Model\nacross Intersectional Strata [Robustness Checks]") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 10),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 6.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(0.50, 0.95, 0.01)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure A4 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figurea4.png", plot = figurea4,
       width = 10, height = 8, dpi = 300)
```

Predicted values for net monthly income in the null model are then visualised in *Figure A6*.

```{r}
# Migration background placeholders are set to their nominal values.
figurea6 <- tablea10 |> 
   mutate(
    y9_generation3 = case_when(
      y9_generation3 == "No, native-born" ~
        "All Grandparents\nGerman-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, native-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, foreign-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nForeign-born",
      TRUE ~ y9_generation3
    )
  ) |>
  ggplot(aes(x = pred_empty, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = pred_empty_lower, xmax = pred_empty_upper)) +
  geom_point() +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generation3 + y9_hgendeg) + 
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off") +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab("Predicted Mean Net Monthly Income (€)") + ylab("") +
  ggtitle("Figure A6 – Predicted Mean Net Monthly Income (€) with\n95% Credible Intervals in the Null Model across\nIntersectional Strata [Robustness Checks]") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 6.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(1450, 2100, 25)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure A6 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figurea6.png", plot = figurea6,
       width = 10, height = 8, dpi = 300)
```

### 5.4 ✧ Visualising the residual random effects

Random effects for probability of being employed under a permanent contract in the null model are visualised in *Figure A5* in the Appendix, facilitating the systematic comparison of strata-level residuals across intersectional strata, representing the difference between values expected by the fixed effects and actual predicted values.

```{r}
# Migration background placeholders are set to their nominal values.
figurea5 <- tablea8 |>
   mutate(
    y9_generation3 = case_when(
      y9_generation3 == "No, native-born" ~
        "All Grandparents\nGerman-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, native-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, foreign-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nForeign-born",
      TRUE ~ y9_generation3
    )
  ) |>
  ggplot(aes(x = ranef, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = ranef_lower, xmax = ranef_upper)) +
  geom_point() +
  # A semi-transparent, jet black line is added to signal y = 0, to foster the interpretability of 95% credible intervals.
  geom_vline(xintercept = 0, color = "#2C302E",
             linetype = "solid", linewidth = 0.5, alpha = 0.5) +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generation3 + y9_hgendeg) +
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off", xlim = c(-0.05, 0.05)) +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab(expression(mu[0][j])) + ylab("") +
  ggtitle(
    "Figure A5 – Interaction Effects for Probability of being\nEmployed under a Permanent Contract (strata-level Residuals μ₀ⱼ) with\n95% Credible Intervals across Intersectional Strata [Robustness Checks]") +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 6.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(-0.05, 0.05, 0.005)) +
  scale_y_discrete(labels = c("Man", "Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure A5 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figurea5.png", plot = figurea5,
       width = 10, height = 8, dpi = 300)
```

Likewise, random effects for net monthly income are visualised in *Figure A7* in the Appendix, facilitating the systematic comparison of strata-level residuals across intersectional strata, representing the difference between values expected by the fixed effects and actual predicted values.

```{r}
# Migration background placeholders are set to their nominal values.
figurea7 <- tablea10 |> 
   mutate(
    y9_generation3 = case_when(
      y9_generation3 == "No, native-born" ~
        "All Grandparents\nGerman-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, native-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nNative-born",
      y9_generation3 == "Yes, foreign-born" ~
        ">=1 Grandparent\nnon-German-born,\nRespondent\nForeign-born",
      TRUE ~ y9_generation3
    )
  ) |>
  ggplot(aes(x = ranef, y = y9_sex, color = y9_sex)) +
  # Predicted values are plotted by points contained in error bars.
  geom_errorbar(aes(xmin = ranef_lower, xmax = ranef_upper)) +
  geom_point() +
  # A semi-transparent, jet black line is added to signal y = 0, to foster the interpretability of 95% credible intervals.
  geom_vline(xintercept = 0, color = "#2C302E",
             linetype = "solid", linewidth = 0.5, alpha = 0.5) +
  # Showing social categories as nested facets with ggh4x.
  facet_nested(~ y9_hisei + y9_generation3 + y9_hgendeg) +
  # The x and y coordinates are flipped for easier visualisation.
  coord_flip(clip = "off", xlim = c(-130, 130)) +
  # Setting labels, titles, and theme elements.
  theme_bw() +
  xlab(expression(""*mu[0][j]*" (€)")) + ylab("") +
  ggtitle("Figure A7 – Interaction Effects for Net Monthly Income (€)\n(strata-level Residuals μ₀ⱼ) with 95% Credible Intervals\nacross Intersectional Strata [Robustness Checks]"
             ) +
  theme(
    plot.title = element_text(size = 13, hjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 11.5),
    axis.title.y = element_text(size = 13),
    strip.placement = "inside",
    strip.text = element_text(size = 6.5),
    legend.position = "bottom",
    legend.text = element_text(size = 11.5),
    legend.title = element_text(size = 11.5)
    ) + scale_x_continuous(breaks = seq(-130, 130, 10)) +
  scale_y_discrete(labels = c("Man","Woman")) +
  labs(color = "Gender") +
  scale_color_manual(values = c("#4281a4", "#E06C9F"))

# Figure A7 is stored in memory with saveRDS.
ggsave(filename = "Tables & Figures/figurea7.png", plot = figurea7,
       width = 10, height = 8, dpi = 300)
```

To conclude, the environment is cleaned from all remaining objects, and references are specified in a supplementary section. References will be sourced and printed from the manyintersections.bib file, and formatted with the APA 7th Edition style, drawn from apa.csl, when the Quarto project is compiled via tinytex.

```{r, include = FALSE}
# Removing all tables and figures to keep the environment clean.
rm(tablea8, tablea10,
   figurea4, figurea5, figurea6, figurea7)

# Removing all versions of the analytic sample and custom helper functions.
rm(imp_main, imp_pred, run_predictions, run_ranef)

# Releasing the unused memory to keep the environment clean.
gc()
```

## 6. References

::: {#refs}
:::
